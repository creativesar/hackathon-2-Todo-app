# Implementation Plan: Phase I - Todo Console App

**Branch**: `phase1-console`
**Date**: 2025-12-28
**Spec**: `specs/phase1-console/spec.md`

## Summary

Build an in-memory Python console todo application with 5 basic features: Add, Delete, Update, View, and Mark Complete. The app stores tasks in memory (list/dict) and provides a CLI interface for user interaction. Development follows spec-driven methodology with all code generated by Claude Code from task definitions.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: UV (package manager), no external runtime dependencies
**Storage**: In-memory Python data structures (list of Task objects)
**Testing**: pytest for unit tests
**Target Platform**: Python 3.13+ on Windows (WSL 2) / Linux / macOS
**Project Type**: Single project (console application)
**Performance Goals**: Instant response (<100ms), minimal memory footprint
**Constraints**: No database, no external APIs, single-session data persistence
**Scale/Scope**: Single user, single session, 5-100 tasks expected

## Constitution Check

*Pass - Phase I requirements align with constitution principles:*
- [x] Spec-driven workflow will be followed
- [x] Clean architecture with separation of concerns
- [x] In-memory storage as required for Phase I
- [x] Console UX excellence with clear commands
- [x] Testable design with importable functions

## Project Structure

### Documentation (this feature)

```
specs/phase1-console/
├── constitution.md     # Project principles (COMPLETED)
├── spec.md             # Feature requirements (COMPLETED)
├── plan.md             # This file (COMPLETED)
├── tasks.md            # Implementation tasks (PENDING)
└── implement.md        # Generated implementation notes (AUTO)
```

### Source Code

```
src/
├── __init__.py         # Package marker
├── models/
│   └── task.py         # Task data class (Pydantic-style)
├── services/
│   └── task_service.py # Business logic (in-memory storage)
├── cli/
│   └── console.py      # CLI interface (argparse/cmd)
└── main.py             # Entry point
tests/
├── __init__.py         # Package marker
└── test_task_service.py # Unit tests
```

**Structure Decision**: Modular structure with clear separation:
- `models/` - Data structures (pure data, no logic)
- `services/` - Business logic (pure functions, testable)
- `cli/` - Presentation layer (user interaction only)

## Architecture

### Data Model

```python
@dataclass
class Task:
    id: int
    title: str
    description: str = ""
    completed: bool = False
    created_at: datetime = field(default_factory=datetime.now)
```

### Service Layer (TaskService)

- `_tasks`: List[Task] - In-memory storage
- `_next_id`: int - Auto-increment counter
- Methods: `add_task()`, `list_tasks()`, `get_task()`, `update_task()`, `delete_task()`, `complete_task()`

### CLI Commands

| Command | Usage | Description |
|---------|-------|-------------|
| `add "Title" ["Description"]` | At prompt: `> add "Buy groceries" "Milk and eggs"` | Create new task |
| `list` | At prompt: `> list` | Display all tasks |
| `complete <id>` | At prompt: `> complete 1` | Mark task as complete |
| `update <id> ["Title"] ["Description"]` | At prompt: `> update 1 "New title"` | Modify task |
| `delete <id>` | At prompt: `> delete 1` | Remove task |
| `help` | At prompt: `> help` | Show commands |
| `exit` | At prompt: `> exit` | Close app |

**Interaction Model**: Interactive REPL session
- App starts with welcome message and `>` prompt
- User types commands at prompt
- Output displayed after each command
- Session continues until `exit` or `quit`

## Complexity Tracking

No constitution violations - this is a straightforward console app within Phase I scope.

---

## Clarifications

### Session 2025-12-28

- Q: Interactive REPL or CLI arguments? → A: Interactive REPL with `>` prompt. Commands entered at prompt like `> add "Buy groceries"`.

**Plan Prepared**: 2025-12-28
**Next Step**: Generate tasks.md from this plan and spec.md
